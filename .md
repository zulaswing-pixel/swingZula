# ðŸ”— Integrating Mega Rocket APIs into Existing Next.js Ecommerce Project

## ðŸ“‹ Overview

This guide explains how to integrate Mega Rocket APIs (email verification + custom checkout) into your **existing Next.js ecommerce platform** that already has:
- âœ… Add to cart system
- âœ… Shopify cart ID management
- âœ… Customer assignment
- âœ… Pending checkout flow

---

## ðŸŽ¯ Integration Flow

```
Your Existing Flow:
Cart â†’ Customer Assignment â†’ Pending Checkout

New Integrated Flow:
Cart â†’ Email Verification â†’ Customer Assignment â†’ Custom Checkout â†’ Order in Shopify
```

---

## ðŸ“¦ Step 1: Install Dependencies

In your existing Next.js project:

```bash
npm install mongoose nodemailer
```

---

## ðŸ“ Step 2: Add Mega Rocket Files to Your Project

### **2.1: Copy Database Connection**

Create `lib/mongodb.js` in your project:

```javascript
import mongoose from 'mongoose';

const MONGODB_URI = process.env.MONGODB_URI;

if (!MONGODB_URI) {
  throw new Error('Please define the MONGODB_URI environment variable');
}

let cached = global.mongoose;

if (!cached) {
  cached = global.mongoose = { conn: null, promise: null };
}

async function connectDB() {
  if (cached.conn) {
    if (mongoose.connection.readyState === 1) {
      return cached.conn;
    }
  }

  if (!cached.promise) {
    const opts = {
      bufferCommands: false,
      maxPoolSize: 10,
      serverSelectionTimeoutMS: 10000,
      socketTimeoutMS: 45000,
      connectTimeoutMS: 10000,
    };

    cached.promise = mongoose.connect(MONGODB_URI, opts).then((mongoose) => {
      console.log('âœ… MongoDB Connected');
      return mongoose;
    });
  }

  try {
    cached.conn = await cached.promise;
    return cached.conn;
  } catch (e) {
    cached.promise = null;
    throw e;
  }
}

export default connectDB;
```

### **2.2: Copy Models**

Create `lib/models/` folder and add:

**`lib/models/Otp.js`:**
```javascript
import mongoose from 'mongoose';

const otpSchema = new mongoose.Schema({
  email: { type: String, required: true, index: true },
  otp: { type: String, required: true },
  created_at: { type: Date, default: Date.now, expires: 300 }, // 5 minutes
});

export default mongoose.models.Otp || mongoose.model('Otp', otpSchema);
```

**`lib/models/VerifiedEmail.js`:**
```javascript
import mongoose from 'mongoose';

const verifiedEmailSchema = new mongoose.Schema({
  email: { type: String, required: true, index: true },
  shop: { type: String, required: true, index: true },
  verified_at: { type: Date, default: Date.now },
}, {
  indexes: [{ email: 1, shop: 1 }]
});

export default mongoose.models.VerifiedEmail || mongoose.model('VerifiedEmail', verifiedEmailSchema);
```

**`lib/models/ShopToken.js`:**
```javascript
import mongoose from 'mongoose';

const shopTokenSchema = new mongoose.Schema({
  shop: { type: String, required: true, unique: true, index: true },
  access_token: { type: String, required: true },
  shop_name: { type: String, required: true },
  email: { type: String, default: '' },
  created_at: { type: Date, default: Date.now },
  updated_at: { type: Date, default: Date.now },
});

export default mongoose.models.ShopToken || mongoose.model('ShopToken', shopTokenSchema);
```

### **2.3: Copy Database Functions**

Create `lib/db.js`:

```javascript
import nodemailer from 'nodemailer';
import connectDB from './mongodb.js';
import Otp from './models/Otp.js';
import VerifiedEmail from './models/VerifiedEmail.js';
import ShopToken from './models/ShopToken.js';

const transporter = nodemailer.createTransport({
  host: 'smtp.gmail.com',
  port: 587,
  secure: false,
  auth: {
    user: process.env.MAIL_USER,
    pass: process.env.MAIL_PASS,
  },
});

export function generateOTP() {
  return Math.floor(1000 + Math.random() * 9000).toString();
}

export async function storeOTPInDatabase(email, otp, shop) {
  await connectDB();
  
  const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
  const verifiedEmail = await VerifiedEmail.findOne({
    email,
    shop,
    verified_at: { $gt: twentyFourHoursAgo },
  });

  if (verifiedEmail) {
    return { success: false, message: 'Email already verified in last 24 hours' };
  }

  const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);
  const existingOtp = await Otp.findOne({
    email,
    created_at: { $gt: fiveMinutesAgo },
  });

  if (existingOtp) {
    return { success: false, message: 'OTP already sent recently' };
  }

  const expiredOtp = await Otp.findOne({
    email,
    created_at: { $lte: fiveMinutesAgo },
  });

  if (expiredOtp) {
    expiredOtp.otp = otp;
    expiredOtp.created_at = new Date();
    await expiredOtp.save();
  } else {
    await Otp.create({ email, otp, created_at: new Date() });
  }

  try {
    await transporter.sendMail({
      to: email,
      subject: 'Your OTP for Checkout Verification',
      html: `<div><h2>Your OTP: ${otp}</h2><p>Valid for 5 minutes</p></div>`,
    });
    return { success: true, message: 'OTP sent successfully' };
  } catch (error) {
    throw new Error('Failed to send OTP email');
  }
}

export async function verifyOTP(email, otp, shop) {
  await connectDB();

  const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);
  const otpRecord = await Otp.findOne({
    email,
    otp,
    created_at: { $gt: fiveMinutesAgo },
  });

  if (otpRecord) {
    const existing = await VerifiedEmail.findOne({ email, shop });
    if (existing) {
      existing.verified_at = new Date();
      await existing.save();
    } else {
      await VerifiedEmail.create({ email, shop, verified_at: new Date() });
    }
    await Otp.deleteOne({ email });
    return { success: true };
  }

  return { success: false, message: 'Invalid or expired OTP' };
}

export async function checkEmailVerified(email, shop) {
  await connectDB();
  const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
  const verifiedEmail = await VerifiedEmail.findOne({
    email,
    shop,
    verified_at: { $gt: twentyFourHoursAgo },
  });
  return { verified: !!verifiedEmail };
}

export async function getShopToken(shop) {
  await connectDB();
  const shopToken = await ShopToken.findOne({ shop });
  if (!shopToken) {
    throw new Error('No shop token found');
  }
  return {
    shop: shopToken.shop,
    access_token: shopToken.access_token,
    shop_name: shopToken.shop_name,
  };
}
```

### **2.4: Create API Routes**

Create `app/api/` folder structure:

**`app/api/send-otp/route.js`:**
```javascript
import { NextResponse } from 'next/server';
import { generateOTP, storeOTPInDatabase } from '@/lib/db';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type',
};

export async function OPTIONS() {
  return new NextResponse(null, { status: 204, headers: corsHeaders });
}

export async function POST(request) {
  try {
    const { email, shop } = await request.json();
    if (!email) {
      return NextResponse.json({ error: 'Email is required' }, { status: 400, headers: corsHeaders });
    }
    const otp = generateOTP();
    const result = await storeOTPInDatabase(email, otp, shop || '');
    return NextResponse.json(result, { status: result.success ? 200 : 429, headers: corsHeaders });
  } catch (error) {
    return NextResponse.json({ error: 'Failed to send OTP' }, { status: 500, headers: corsHeaders });
  }
}
```

**`app/api/verify-otp/route.js`:**
```javascript
import { NextResponse } from 'next/server';
import { verifyOTP } from '@/lib/db';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type',
};

export async function OPTIONS() {
  return new NextResponse(null, { status: 204, headers: corsHeaders });
}

export async function POST(request) {
  try {
    const { email, otp, shop } = await request.json();
    if (!email || !otp || !shop) {
      return NextResponse.json({ error: 'Email, OTP, and shop are required' }, { status: 400, headers: corsHeaders });
    }
    const result = await verifyOTP(email, otp, shop);
    return NextResponse.json(result, { status: result.success ? 200 : 400, headers: corsHeaders });
  } catch (error) {
    return NextResponse.json({ error: 'Failed to verify OTP' }, { status: 500, headers: corsHeaders });
  }
}
```

**`app/api/check-verified/route.js`:**
```javascript
import { NextResponse } from 'next/server';
import { checkEmailVerified } from '@/lib/db';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type',
};

export async function OPTIONS() {
  return new NextResponse(null, { status: 204, headers: corsHeaders });
}

export async function POST(request) {
  try {
    const { email, shop } = await request.json();
    if (!email || !shop) {
      return NextResponse.json({ error: 'Email and shop are required' }, { status: 400, headers: corsHeaders });
    }
    const result = await checkEmailVerified(email, shop);
    return NextResponse.json({ verified: result.verified }, { status: 200, headers: corsHeaders });
  } catch (error) {
    return NextResponse.json({ error: 'Failed to check verification' }, { status: 500, headers: corsHeaders });
  }
}
```

**`app/api/custom-checkout/route.js`:**
```javascript
import { NextResponse } from 'next/server';
import { getShopToken } from '@/lib/db';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type',
};

export async function OPTIONS() {
  return new NextResponse(null, { status: 204, headers: corsHeaders });
}

export async function POST(request) {
  try {
    const { shop, email, name, address, lineItems, customerId, paymentMethod, cartId } = await request.json();

    if (!lineItems || lineItems.length === 0) {
      return NextResponse.json({ error: 'No line items found' }, { status: 400, headers: corsHeaders });
    }

    const { access_token: accessToken, shop_name } = await getShopToken(shop);
    const subtotal = lineItems.reduce((sum, item) => sum + item.price * item.quantity, 0);

    const orderPayload = {
      email,
      shipping_address: {
        address1: address,
        name,
        country: 'India',
      },
      line_items: lineItems.map((item) => ({
        variant_id: item.variant_id,
        quantity: item.quantity,
        price: item.price.toString(),
      })),
      financial_status: 'pending',
      send_receipt: true,
      transactions: [{
        kind: 'sale',
        status: 'pending',
        amount: subtotal.toString(),
      }],
      note: `Order from custom checkout. Cart ID: ${cartId || 'N/A'}`,
      tags: `custom-checkout,megarocket,${paymentMethod || 'wallet'}`,
      note_attributes: [
        { name: 'customer_id', value: customerId || '' },
        { name: 'cart_id', value: cartId || '' }
      ],
    };

    const orderResponse = await fetch(`https://${shop}/admin/api/2024-01/orders.json`, {
      method: 'POST',
      headers: {
        'X-Shopify-Access-Token': accessToken,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ order: orderPayload }),
    });

    const orderData = await orderResponse.json();

    if (!orderData || !orderData.order) {
      throw new Error(`Shopify API error: ${JSON.stringify(orderData.errors || 'Unknown error')}`);
    }

    return NextResponse.json({
      success: true,
      message: 'Order created successfully',
      orderId: orderData.order.id,
      orderNumber: orderData.order.order_number,
      orderStatusUrl: orderData.order.order_status_url,
      shopName: shop_name,
      totalPrice: orderData.order.total_price,
    }, { headers: corsHeaders });
  } catch (error) {
    return NextResponse.json({ success: false, message: error.message }, { status: 500, headers: corsHeaders });
  }
}
```

---

## ðŸ”„ Step 3: Integrate with Your Existing Cart System

### **3.1: Modify Your Checkout Component**

Assuming you have a checkout component, modify it like this:

```javascript
// app/components/Checkout.jsx or pages/checkout.jsx
'use client';

import { useState, useEffect } from 'react';

export default function Checkout({ cartId, shopifyCartId, customerId }) {
  const [step, setStep] = useState(1); // 1: Email, 2: OTP, 3: Details, 4: Success
  const [email, setEmail] = useState('');
  const [otp, setOtp] = useState('');
  const [verified, setVerified] = useState(false);
  const [formData, setFormData] = useState({
    name: '',
    address: '',
    phone: '',
    pincode: ''
  });
  const [cartItems, setCartItems] = useState([]);
  const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000/api';
  const SHOP_DOMAIN = process.env.NEXT_PUBLIC_SHOP_DOMAIN;

  // Load cart items (your existing function)
  useEffect(() => {
    loadCartItems();
  }, []);

  // Check if email already verified
  useEffect(() => {
    if (email) {
      checkVerificationStatus();
    }
  }, [email]);

  const loadCartItems = async () => {
    // Your existing cart loading logic
    // Example:
    // const response = await fetch(`/api/cart/${cartId}`);
    // const data = await response.json();
    // setCartItems(data.items);
  };

  const checkVerificationStatus = async () => {
    try {
      const response = await fetch(`${API_URL}/check-verified`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, shop: SHOP_DOMAIN })
      });
      const { verified } = await response.json();
      if (verified) {
        setVerified(true);
        setStep(3); // Skip to details form
      }
    } catch (error) {
      console.error('Verification check failed:', error);
    }
  };

  const sendOTP = async () => {
    try {
      const response = await fetch(`${API_URL}/send-otp`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, shop: SHOP_DOMAIN })
      });
      const result = await response.json();
      if (result.success) {
        setStep(2); // Move to OTP step
      } else {
        alert(result.message);
      }
    } catch (error) {
      alert('Failed to send OTP');
    }
  };

  const verifyOTP = async () => {
    try {
      const response = await fetch(`${API_URL}/verify-otp`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, otp, shop: SHOP_DOMAIN })
      });
      const result = await response.json();
      if (result.success) {
        setVerified(true);
        setStep(3); // Move to details form
      } else {
        alert(result.message);
      }
    } catch (error) {
      alert('Failed to verify OTP');
    }
  };

  const createOrder = async () => {
    // Convert your cart items to lineItems format
    const lineItems = cartItems.map(item => ({
      variant_id: item.variant_id, // Your cart item structure
      quantity: item.quantity,
      price: item.price
    }));

    try {
      const response = await fetch(`${API_URL}/custom-checkout`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          shop: SHOP_DOMAIN,
          email: email,
          name: formData.name,
          address: formData.address,
          lineItems: lineItems,
          customerId: customerId,
          paymentMethod: 'wallet',
          cartId: shopifyCartId // Pass your Shopify cart ID
        })
      });

      const result = await response.json();
      
      if (result.success) {
        // Update your cart status to "completed" or delete it
        await updateCartStatus(cartId, 'completed');
        
        setStep(4); // Success step
        // Optionally redirect
        setTimeout(() => {
          window.location.href = result.orderStatusUrl;
        }, 3000);
      } else {
        alert('Order failed: ' + result.message);
      }
    } catch (error) {
      alert('Error creating order: ' + error.message);
    }
  };

  const updateCartStatus = async (cartId, status) => {
    // Your existing function to update cart status
    // Example:
    // await fetch(`/api/cart/${cartId}`, {
    //   method: 'PATCH',
    //   body: JSON.stringify({ status })
    // });
  };

  return (
    <div className="checkout-container">
      {/* Step 1: Email Input */}
      {step === 1 && (
        <div>
          <h2>Enter Your Email</h2>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            placeholder="your@email.com"
          />
          <button onClick={sendOTP}>Send OTP</button>
        </div>
      )}

      {/* Step 2: OTP Verification */}
      {step === 2 && (
        <div>
          <h2>Enter OTP</h2>
          <input
            type="text"
            value={otp}
            onChange={(e) => setOtp(e.target.value)}
            placeholder="4-digit OTP"
            maxLength={4}
          />
          <button onClick={verifyOTP}>Verify</button>
        </div>
      )}

      {/* Step 3: Customer Details */}
      {step === 3 && (
        <div>
          <h2>Enter Your Details</h2>
          <input
            type="text"
            placeholder="Full Name"
            value={formData.name}
            onChange={(e) => setFormData({ ...formData, name: e.target.value })}
          />
          <input
            type="text"
            placeholder="Address"
            value={formData.address}
            onChange={(e) => setFormData({ ...formData, address: e.target.value })}
          />
          <input
            type="text"
            placeholder="Phone"
            value={formData.phone}
            onChange={(e) => setFormData({ ...formData, phone: e.target.value })}
          />
          <input
            type="text"
            placeholder="Pincode"
            value={formData.pincode}
            onChange={(e) => setFormData({ ...formData, pincode: e.target.value })}
          />
          <button onClick={createOrder}>Place Order</button>
        </div>
      )}

      {/* Step 4: Success */}
      {step === 4 && (
        <div>
          <h2>âœ… Order Placed Successfully!</h2>
          <p>Your order has been created in Shopify.</p>
        </div>
      )}
    </div>
  );
}
```

---

## ðŸ”— Step 4: Connect with Your Existing Cart API

### **4.1: Modify Your Cart API to Include Shopify Cart ID**

If you have a cart API endpoint, ensure it stores Shopify cart ID:

```javascript
// app/api/cart/[cartId]/route.js (example)
export async function GET(request, { params }) {
  const { cartId } = params;
  
  // Your existing cart retrieval logic
  const cart = await getCartFromDatabase(cartId);
  
  return NextResponse.json({
    ...cart,
    shopifyCartId: cart.shopify_cart_id, // Make sure this is included
    items: cart.items.map(item => ({
      ...item,
      variant_id: item.shopify_variant_id, // Ensure variant_id is available
      price: item.price,
      quantity: item.quantity
    }))
  });
}
```

### **4.2: Update Cart When Order Created**

After order creation, update your cart:

```javascript
// In your checkout component after order creation
const updateCartAfterOrder = async (cartId, orderId) => {
  await fetch(`/api/cart/${cartId}`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      status: 'completed',
      order_id: orderId,
      completed_at: new Date().toISOString()
    })
  });
};
```

---

## ðŸ“ Step 5: Environment Variables

Add to your `.env.local`:

```env
MONGODB_URI=mongodb+srv://username:password@cluster.mongodb.net/database
MAIL_USER=your-email@gmail.com
MAIL_PASS=your-app-password
JWT_SECRET=your-secret-key
NEXT_PUBLIC_API_URL=http://localhost:3000/api
NEXT_PUBLIC_SHOP_DOMAIN=your-shop.myshopify.com
```

---

## ðŸŽ¯ Step 6: Integration Points

### **Point 1: Before Checkout Button**

In your existing checkout page/component, add email verification before allowing checkout:

```javascript
// Before showing checkout form
const [emailVerified, setEmailVerified] = useState(false);

// Check if already verified
useEffect(() => {
  checkIfVerified();
}, []);

const checkIfVerified = async () => {
  const email = getCustomerEmail(); // Your existing function
  if (email) {
    const response = await fetch(`${API_URL}/check-verified`, {
      method: 'POST',
      body: JSON.stringify({ email, shop: SHOP_DOMAIN })
    });
    const { verified } = await response.json();
    setEmailVerified(verified);
  }
};
```

### **Point 2: Cart to Order Conversion**

When converting cart to order, use custom checkout API:

```javascript
// Your existing checkout function
const handleCheckout = async () => {
  // 1. Get cart items
  const cart = await getCart(cartId);
  
  // 2. Convert to lineItems
  const lineItems = cart.items.map(item => ({
    variant_id: item.shopify_variant_id,
    quantity: item.quantity,
    price: item.price
  }));
  
  // 3. Create order via custom checkout
  const order = await createOrderViaAPI({
    shop: SHOP_DOMAIN,
    email: verifiedEmail,
    name: customerName,
    address: customerAddress,
    lineItems: lineItems,
    customerId: customerId,
    cartId: cart.shopify_cart_id // Pass Shopify cart ID
  });
  
  // 4. Update your cart status
  await updateCart(cartId, { status: 'completed', order_id: order.orderId });
};
```

---

## ðŸ”„ Complete Flow Example

```javascript
// Complete integration example
async function completeCheckoutFlow(cartId, customerId) {
  // Step 1: Get cart
  const cart = await fetch(`/api/cart/${cartId}`).then(r => r.json());
  
  // Step 2: Get customer email (your existing function)
  const customer = await getCustomer(customerId);
  const email = customer.email;
  
  // Step 3: Check if verified
  const verifiedResponse = await fetch(`${API_URL}/check-verified`, {
    method: 'POST',
    body: JSON.stringify({ email, shop: SHOP_DOMAIN })
  });
  const { verified } = await verifiedResponse.json();
  
  // Step 4: If not verified, show OTP flow
  if (!verified) {
    // Show OTP modal/component
    const otpVerified = await showOTPVerification(email);
    if (!otpVerified) return; // User cancelled
  }
  
  // Step 5: Get customer details (your existing form)
  const customerDetails = await getCustomerDetails();
  
  // Step 6: Convert cart to order
  const lineItems = cart.items.map(item => ({
    variant_id: item.shopify_variant_id,
    quantity: item.quantity,
    price: item.price
  }));
  
  const orderResponse = await fetch(`${API_URL}/custom-checkout`, {
    method: 'POST',
    body: JSON.stringify({
      shop: SHOP_DOMAIN,
      email: email,
      name: customerDetails.name,
      address: customerDetails.address,
      lineItems: lineItems,
      customerId: customerId,
      cartId: cart.shopify_cart_id,
      paymentMethod: 'wallet'
    })
  });
  
  const order = await orderResponse.json();
  
  // Step 7: Update cart status
  await fetch(`/api/cart/${cartId}`, {
    method: 'PATCH',
    body: JSON.stringify({
      status: 'completed',
      order_id: order.orderId,
      shopify_order_id: order.orderId
    })
  });
  
  return order;
}
```

---

## âœ… Testing Checklist

- [ ] MongoDB connection works
- [ ] OTP sending works
- [ ] OTP verification works
- [ ] Email verification check works
- [ ] Cart items convert to lineItems correctly
- [ ] Order created in Shopify with correct cart ID
- [ ] Cart status updated after order
- [ ] Customer assignment maintained
- [ ] Existing cart system still works
- [ ] Integration doesn't break existing functionality

---

## ðŸŽ‰ Result

Your existing Next.js ecommerce platform now has:
- âœ… Email verification before checkout
- âœ… OTP system integrated
- âœ… Custom checkout that creates orders in Shopify
- âœ… Cart ID tracking in orders
- âœ… Customer assignment maintained
- âœ… Seamless integration with existing cart system

**Your existing cart system continues to work, but now with email verification and Shopify order creation!** ðŸš€
